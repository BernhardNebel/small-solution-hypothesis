# This file contains SageMath code that helps to verify or make plausible
# the claims in the paper "The Small Solution Hypothesis for MAPF on Directed Graphs Is True."
# One can paste this code into the online evaluator for SageMath at https://sagecell.sagemath.org/
# and press "Evaluate" in order to run the code.

def t0cycle_claim():
    print()
    print("CHECK claim that T0-pairs do induce groups that do not contain 3-cycles")
    print("=======================================================================")
    for (n1, n2, n3) in [(1,3,2), (2,2,2), (1,2,3)]:
        G = SymmetricGroup(n1+n2+n3)
        id = G([])	
        a = G(tuple(range(1,n2+1)) + tuple(range(n2+1,n2+n1+1)))
        b = G(tuple(range(1,n2+1)) + tuple(range(n2+n1+1,n2+n1+n3+1)))
        gen = [a, b, a^-1, b^-1]
        print("Check group generated by cycle pair type = (", n1, n2, n3, ")")
        cyc = False
        for p in G.subgroup(gen).list():
            if len(p.cycle_type(False)) == 1:
                if p.cycle_type(False)[0] == 3:
                    print("3-cycle:", p)
                    cyc = True
                    break
        if (cyc):
            print("3-cycle found")
        else:
            print("No 3-cycle found")
        print()
    print()
        
def three_cycle_claim(nmax):
    print("CHECK the case analysis of the Lemma about 3-cycles up to", nmax, "nodes for each part")
    print("================================================================================")
    for n1 in range(0,nmax+1):
        for n2 in range(0,nmax+1):
            for n3 in range(0,nmax+1):
                if (n2 == 0) or (n3 < n1):
                    continue
                if (n1 == 0) and (n2 < 2 or n3 == 0):
                    continue
                A1    = (n2+1 if n1>0 else 0)
                A2    = (A1+1 if n1>1 else 0)
                AN1   = (n2+n1 if n1>0 else 0)
                B1    = n2
                B2    = (B1-1 if n2>1 else 0)
                BN2   = 1
                BN2m1 = (2 if n2 > 1 else 0)
                C1    = n1+n2+1
                C2    = (C1+1 if n3>1 else 0)
                CN3   = n1+n2+n3
                CN3m2 = (CN3-2 if n3 > 2 else 0)
                G = SymmetricGroup(n1+n2+n3)
                id = G([])
                a = G(tuple(range(1,n2+1)) + tuple(range(n2+1,n2+n1+1)))
                b = G(tuple(range(1,n2+1)) + tuple(range(n2+n1+1,n2+n1+n3+1)))
                if n1 == 0:
                    assert (n2 >= 2 and n3 >= 1 and b*a^-1*b^-1*a == G((BN2, CN3, B1))),\
                      "Case (0,_,_) failed"
                elif n1 >= 1 and n2 == 1:
                    assert (b*a^-1*b^-1*a == G((B1, A1, CN3))), "Case (>= 1, 1, _) failed"
                elif n1 == 1 and n2 == 2:
                    assert (len(a.cycle_type(False)) == 1 and a.cycle_type(False)[0] == 3),\
                      "Case (1,2,_) failed"
                elif n1 == 1 and n2 >= 3 and n3 == 1:
                    assert (a^-1 * b == G((BN2, A1, C1))),\
                      "Case (1,>=3,1) failed"
                elif n1 == 1 and n2 == 3 and n3 == 2:
                    pass # nothing to do here
                elif n1 == 1 and n2 == 3 and n3 >= 3:
                    x = b^2*(a^-1*b)^2*b^-2
                    sb = b*a^-1*b^-1*a
                    assert (sb == G([(BN2, CN3), (B1, A1)]) and
                                x*sb*x^-1 == G([(BN2, CN3), (A1, CN3m2)]) and
                                sb*x*sb*x^-1 == G((B1, CN3m2, A1))),\
                        "Case (1,3,>=3) failed"
                elif n1 == 1 and n2 >= 4 and n3 >= 2:
                    sa = a*b^-1*a^-1*b
                    assert (sa == G([(BN2, AN1), (B1, C1)]) and
                                b^-1*sa*b == G([(BN2m1, AN1), (C1, C2)]) and
                                a^2*(b^-1*sa*b)*a^-2 == G([(B2, AN1), (C1, C2)]) and
                                (b^-1*sa*b)*(a^2*(b^-1*sa*b)*a^-2) == G((BN2m1, B2, AN1))),\
                        "Case (1,>=4,>=2) failed"
                elif n1 == 2 and n2 == 2 and n3 == 2:
                    pass # nothig to do
                elif n1 == 2 and n2 >= 3 and n3 == 2:
                    sb = b*a^-1*b^-1*a
                    assert (sb == G([(BN2, CN3), (A1, B1)]) and
                                a^-1*sb*a == G([(BN2m1, CN3), (A1, A2)]) and
                                b^2*(a^-1*sb*a)*b^-2 ==  G([(B1, CN3), (A1, A2)]) and
                                (a^-1*sb*a)*(b^2*(a^-1*sb*a)*b^-2) == G((BN2m1, B1, CN3))),\
                        "Case (2,>=3,2) failed"
                elif n1 >= 2 and n2 >= 2 and n3 >= 3:
                    sb = b*a^-1*b^-1*a
                    assert (sb == G([(BN2, CN3), (A1, B1)]) and
                                a^-1*sb*a == G([(BN2m1, CN3), (A1, A2)]) and
                                b^2*(a^-1*sb*a)*b^-2 ==  G([(CN3m2, CN3), (A1, A2)]) and
                                (a^-1*sb*a)*(b^2*(a^-1*sb*a)*b^-2) == G((BN2m1, CN3m2, CN3))),\
                        "Case (>=2,>=3,>=3) failed"                    
                else:
                    assert False, "Forgotten case:" + str((n1,n2,n3))
    print("No deviation found\n")


def sharednodes(c1, c2):
    # computes number of shared nodes of two simple cycles
    return len(set(c1) & set(c2))

def pairtype(c1, c2):
    # computes the type of a pair of cycles that share some nodes
    if len(c1) > len(c2):
        c1, c2 = c2, c1
    if sharednodes(c1,c2) < 2:
        return None
    else:
        return (len(c1) - sharednodes(c1,c2) - 1, sharednodes(c1,c2) - 1,
                    len(c2) - sharednodes(c1,c2) - 1)

def checkforpair(dig):
    # iterate over all cycle pairs in a digraph
    # and try to identify a non-T0-pair
    for c1 in dig.all_simple_cycles():
        for c2 in dig.all_simple_cycles():
            if c1 != c2:
                ctype = pairtype(c1, c2)
                if ctype not in [(2,2,2), (1,3,2), None]:
                    return ctype
    return None

def gen_t0pair_ext():
    print("GENERATE all T0-pair extensions containing only T0-pairs")
    print("========================================================")
    t0adict = { 'a1': ['a2'], 'a2' : [ 'z' ], 'z': [ 'b2' ], 'b2': [ 'b1' ], 
        'b1' : ['a1', 'c1'], 'c1': ['c2'], 'c2': ['z'] }
    t0bdict = {  'a1' : [ 'z' ], 'z': [ 'b3' ], 'b3': ['b2'], 'b2': [ 'b1' ], 
        'b1' : ['a1', 'c1'], 'c1': ['c2'], 'c2': ['z'] }
    ears = [ ['e1'], ['e1', 'e2'],  ['e1', 'e2', 'e3'] ]

    for graph, ptype in ( (t0adict, (2,2,2)), (t0bdict, (1,3,2)) ):
        for head in graph.keys():
            for tail in graph.keys():
                if tail == head:
                    continue
                for ear in ears:
                    t0 = DiGraph(graph)
                    t0.add_path([ head ] + ear + [ tail ])
                    if not checkforpair(t0):
                        print("Only T0s in pair of type", ptype,
                                "for ear:", [ head ] + ear + [ tail ])
    print()


def t0_ext_claim():
    print("Check that all extended T0-pairs containing only T0s can generate a 3-cycle")
    print("===========================================================================")
    G = SymmetricGroup(8)
    id = G([])

    # (a) case z to c_1 for (2,2,2)
    a = G((1,2,3,4))
    b = G((1,2,5,6))
    c = G((8,7,5,6))
    p = a^-1*c^-1*b^-1*a^2*c^-1*b^-1*c^-1
    assert len(p.cycle_type(False)) == 1 and p.cycle_type(False)[0] == 3

    # (b) case c_2 to b_1 for (2,2,2)
    a = G((1,2,3,4))
    b = G((1,2,5,6))
    c = G((5,6,8,7))
    p = a^-1*c^-1*b^-1*a^2*c^-1*b^-1*c^-1
    assert len(p.cycle_type(False)) == 1 and p.cycle_type(False)[0] == 3

    # (c) case b1 to z for (2,2,2)
    a = G((1,2,3,4))
    b = G((1,2,5,6))
    c = G((1,2,7,8))
    p = a*b*c*a^-1*b^-1*c^-1
    assert len(p.cycle_type(False)) == 1 and p.cycle_type(False)[0] == 3

    # (d) case c1 to a2 for (2,2,2)
    a = G((1,2,3,4))
    b = G((1,2,5,6))
    c = G((1,2,5,7,4))
    gen = [a, b, c, a^-1, b^-1, c^-1]
    p = c*b^-1*c^-1*a
    assert len(p.cycle_type(False)) == 1 and p.cycle_type(False)[0] == 3

    # (e) case b2 to c2 for (1,3,2)
    a = G((1,2,3,4))
    b = G((1,2,3,5,6))
    c = G((1,2,7,6))
    p = b^-1*c^-1*b*a
    assert len(p.cycle_type(False)) == 1 and p.cycle_type(False)[0] == 3

    # (f) case b2 to c2 for (1,3,2)
    a = G((1,2,3,4))
    b = G((1,2,5,6,4))
    c = G((1,2,5,7))
    p = b*c^-1*b^-1*a
    assert len(p.cycle_type(False)) == 1 and p.cycle_type(False)[0] == 3

    print("No deviation found\n")


    
# Now check all claims
t0cycle_claim()
three_cycle_claim(10)
gen_t0pair_ext()
t0_ext_claim()
